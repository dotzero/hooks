// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package handlers

import (
	"github.com/dotzero/hooks/app/models"
	"io"
	"sync"
)

// storeMock is a mock implementation of store.
//
// 	func TestSomethingThatUsesstore(t *testing.T) {
//
// 		// make and configure a mocked store
// 		mockedstore := &storeMock{
// 			HookFunc: func(name string) (*models.Hook, error) {
// 				panic("mock out the Hook method")
// 			},
// 			HooksFunc: func(names []string) ([]*models.Hook, error) {
// 				panic("mock out the Hooks method")
// 			},
// 			PutHookFunc: func(hook *models.Hook) error {
// 				panic("mock out the PutHook method")
// 			},
// 			PutRequestFunc: func(hook string, req *models.Request) error {
// 				panic("mock out the PutRequest method")
// 			},
// 			RequestsFunc: func(hook string) ([]*models.Request, error) {
// 				panic("mock out the Requests method")
// 			},
// 		}
//
// 		// use mockedstore in code that requires store
// 		// and then make assertions.
//
// 	}
type storeMock struct {
	// HookFunc mocks the Hook method.
	HookFunc func(name string) (*models.Hook, error)

	// HooksFunc mocks the Hooks method.
	HooksFunc func(names []string) ([]*models.Hook, error)

	// PutHookFunc mocks the PutHook method.
	PutHookFunc func(hook *models.Hook) error

	// PutRequestFunc mocks the PutRequest method.
	PutRequestFunc func(hook string, req *models.Request) error

	// RequestsFunc mocks the Requests method.
	RequestsFunc func(hook string) ([]*models.Request, error)

	// calls tracks calls to the methods.
	calls struct {
		// Hook holds details about calls to the Hook method.
		Hook []struct {
			// Name is the name argument value.
			Name string
		}
		// Hooks holds details about calls to the Hooks method.
		Hooks []struct {
			// Names is the names argument value.
			Names []string
		}
		// PutHook holds details about calls to the PutHook method.
		PutHook []struct {
			// Hook is the hook argument value.
			Hook *models.Hook
		}
		// PutRequest holds details about calls to the PutRequest method.
		PutRequest []struct {
			// Hook is the hook argument value.
			Hook string
			// Req is the req argument value.
			Req *models.Request
		}
		// Requests holds details about calls to the Requests method.
		Requests []struct {
			// Hook is the hook argument value.
			Hook string
		}
	}
	lockHook       sync.RWMutex
	lockHooks      sync.RWMutex
	lockPutHook    sync.RWMutex
	lockPutRequest sync.RWMutex
	lockRequests   sync.RWMutex
}

// Hook calls HookFunc.
func (mock *storeMock) Hook(name string) (*models.Hook, error) {
	if mock.HookFunc == nil {
		panic("storeMock.HookFunc: method is nil but store.Hook was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockHook.Lock()
	mock.calls.Hook = append(mock.calls.Hook, callInfo)
	mock.lockHook.Unlock()
	return mock.HookFunc(name)
}

// HookCalls gets all the calls that were made to Hook.
// Check the length with:
//     len(mockedstore.HookCalls())
func (mock *storeMock) HookCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockHook.RLock()
	calls = mock.calls.Hook
	mock.lockHook.RUnlock()
	return calls
}

// Hooks calls HooksFunc.
func (mock *storeMock) Hooks(names []string) ([]*models.Hook, error) {
	if mock.HooksFunc == nil {
		panic("storeMock.HooksFunc: method is nil but store.Hooks was just called")
	}
	callInfo := struct {
		Names []string
	}{
		Names: names,
	}
	mock.lockHooks.Lock()
	mock.calls.Hooks = append(mock.calls.Hooks, callInfo)
	mock.lockHooks.Unlock()
	return mock.HooksFunc(names)
}

// HooksCalls gets all the calls that were made to Hooks.
// Check the length with:
//     len(mockedstore.HooksCalls())
func (mock *storeMock) HooksCalls() []struct {
	Names []string
} {
	var calls []struct {
		Names []string
	}
	mock.lockHooks.RLock()
	calls = mock.calls.Hooks
	mock.lockHooks.RUnlock()
	return calls
}

// PutHook calls PutHookFunc.
func (mock *storeMock) PutHook(hook *models.Hook) error {
	if mock.PutHookFunc == nil {
		panic("storeMock.PutHookFunc: method is nil but store.PutHook was just called")
	}
	callInfo := struct {
		Hook *models.Hook
	}{
		Hook: hook,
	}
	mock.lockPutHook.Lock()
	mock.calls.PutHook = append(mock.calls.PutHook, callInfo)
	mock.lockPutHook.Unlock()
	return mock.PutHookFunc(hook)
}

// PutHookCalls gets all the calls that were made to PutHook.
// Check the length with:
//     len(mockedstore.PutHookCalls())
func (mock *storeMock) PutHookCalls() []struct {
	Hook *models.Hook
} {
	var calls []struct {
		Hook *models.Hook
	}
	mock.lockPutHook.RLock()
	calls = mock.calls.PutHook
	mock.lockPutHook.RUnlock()
	return calls
}

// PutRequest calls PutRequestFunc.
func (mock *storeMock) PutRequest(hook string, req *models.Request) error {
	if mock.PutRequestFunc == nil {
		panic("storeMock.PutRequestFunc: method is nil but store.PutRequest was just called")
	}
	callInfo := struct {
		Hook string
		Req  *models.Request
	}{
		Hook: hook,
		Req:  req,
	}
	mock.lockPutRequest.Lock()
	mock.calls.PutRequest = append(mock.calls.PutRequest, callInfo)
	mock.lockPutRequest.Unlock()
	return mock.PutRequestFunc(hook, req)
}

// PutRequestCalls gets all the calls that were made to PutRequest.
// Check the length with:
//     len(mockedstore.PutRequestCalls())
func (mock *storeMock) PutRequestCalls() []struct {
	Hook string
	Req  *models.Request
} {
	var calls []struct {
		Hook string
		Req  *models.Request
	}
	mock.lockPutRequest.RLock()
	calls = mock.calls.PutRequest
	mock.lockPutRequest.RUnlock()
	return calls
}

// Requests calls RequestsFunc.
func (mock *storeMock) Requests(hook string) ([]*models.Request, error) {
	if mock.RequestsFunc == nil {
		panic("storeMock.RequestsFunc: method is nil but store.Requests was just called")
	}
	callInfo := struct {
		Hook string
	}{
		Hook: hook,
	}
	mock.lockRequests.Lock()
	mock.calls.Requests = append(mock.calls.Requests, callInfo)
	mock.lockRequests.Unlock()
	return mock.RequestsFunc(hook)
}

// RequestsCalls gets all the calls that were made to Requests.
// Check the length with:
//     len(mockedstore.RequestsCalls())
func (mock *storeMock) RequestsCalls() []struct {
	Hook string
} {
	var calls []struct {
		Hook string
	}
	mock.lockRequests.RLock()
	calls = mock.calls.Requests
	mock.lockRequests.RUnlock()
	return calls
}

// tplMock is a mock implementation of tpl.
//
// 	func TestSomethingThatUsestpl(t *testing.T) {
//
// 		// make and configure a mocked tpl
// 		mockedtpl := &tplMock{
// 			ExecuteFunc: func(wr io.Writer, data interface{}) error {
// 				panic("mock out the Execute method")
// 			},
// 		}
//
// 		// use mockedtpl in code that requires tpl
// 		// and then make assertions.
//
// 	}
type tplMock struct {
	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(wr io.Writer, data interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// Wr is the wr argument value.
			Wr io.Writer
			// Data is the data argument value.
			Data interface{}
		}
	}
	lockExecute sync.RWMutex
}

// Execute calls ExecuteFunc.
func (mock *tplMock) Execute(wr io.Writer, data interface{}) error {
	if mock.ExecuteFunc == nil {
		panic("tplMock.ExecuteFunc: method is nil but tpl.Execute was just called")
	}
	callInfo := struct {
		Wr   io.Writer
		Data interface{}
	}{
		Wr:   wr,
		Data: data,
	}
	mock.lockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	mock.lockExecute.Unlock()
	return mock.ExecuteFunc(wr, data)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//     len(mockedtpl.ExecuteCalls())
func (mock *tplMock) ExecuteCalls() []struct {
	Wr   io.Writer
	Data interface{}
} {
	var calls []struct {
		Wr   io.Writer
		Data interface{}
	}
	mock.lockExecute.RLock()
	calls = mock.calls.Execute
	mock.lockExecute.RUnlock()
	return calls
}
